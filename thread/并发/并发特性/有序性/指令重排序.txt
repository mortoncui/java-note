--------------------------------编译器重排序
不按照代码顺序 产生 汇编代码

如何解决：优化屏障
1. 内存信息已经修改，屏障后的寄存器的值必须从内存中重新获取
2. 必须按照代码顺序产生汇编代码，不得越过屏障

--------------------------------cpu乱序执行
指令的执行过程为：
	Java代码-->字节码-解释为-->根据字节码执行对应的C/C++代码-->C/C++代码被编译成汇编语言-->和硬件电路交互 来访问内存（读取，写入）
现实中，为了获取更好的性能，在保证 最终执行结果和指令顺序执行的结果 相同的情况下，JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题

int i = 0;              
boolean flag = false;
i = 1;                //语句1  
flag = true;          //语句2
从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候，会保证语句1一定会在语句2前面执行吗？不一定，这里可能会发生指令重排序
	处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的
	处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。
	指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。
上面的例子中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。

在指令重排序后，如果这些指定只被一个线程执行，那么没有问题，但是如果被多个线程执行，就有可能会引发问题：
//线程1:
context = loadContext();   //语句1
inited = true;             //语句2
//线程2:
while(!inited ){
  sleep()
}
doSomethingwithconfig(context);
由于语句1和语句2没有数据依赖性，因此可能会被重排序。
假如发生了重排序，在线程1执行过程中先执行语句2，而此时线程2会以为初始化工作已经完成，那么就会跳出while循环，后去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。

--------------------------------哪些情况下不能重排序
操作1 和 操作2 之间存在着数据依赖
	如：都操作于 同一个变量a，且至少有一个操作 在写变量a
此刻，不允许对 操作1和2 进行重排序

--------------------------------怎么解决指令重排序在多线程中的问题
内存屏障
参见：内存屏障.txt

---------------之下为以前的内容
>>>通过volatile
例子：
int x,y;
volatile boolean flag;
 
x = 2;         //语句1
y = 0;         //语句2
flag = true;   //语句3
x = 4;         //语句4
y = -1;        //语句5

由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，
	不会将语句3放到语句1、语句2前面，
		执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。
	也不会将语句3放到语句4、语句5后面。
	说明：但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。

>>>通过加锁，如：synchronized
其保证在 共享变量的访问上，是串行访问的