用于获取独占资源
public final void acquire(int arg) {
	if (!tryAcquire(arg) &&
		acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
		selfInterrupt();
}

整体流程：
. 请求资源
. 该资源是否可以被请求（由子类的tryAcquire来实现）
	如果可以请求得到，则线程未被阻塞，则继续执行
	否则，
		生成一个节点（代表了本次请求），插入到链表尾部
		当该节点是head的后继时，再次尝试是否可获得资源
		当还是获取不到时，阻塞线程
			需要：前继节点的status需要为SIGNAL，为了：该前继节点释放资源后，需要唤醒其后继节点（即是：自身节点）的thread 来试图获取资源（重走acquireQueued中的for）

//试图获得锁（此时已经生成了节点，位于链表中）
//注意：即使生成了节点 位于链表中，还是可以一次获得资源的
	//如：轮到自己请求时，之前占用资源的线程释放了资源（而之前，自己通过tryAcquire没有获得到资源（CAS把state从0设置为1时 失败，或，之前占用资源的线程 并非 自己线程））
//而当之前占用资源的线程释放了资源，唤醒了head后继，后继线程还是会继续走for循环来 试图获取资源
//返回：node是否被interrupt
final boolean acquireQueued(final Node node, int arg) {
	boolean failed = true;
	try {
		boolean interrupted = false;
		//这里开启了一个for循环，为什么：
		//当release资源时，会唤醒 head的后继Node的thread
		//该thread被唤醒后，继续执行for循环：试图获得锁（当获取到锁后，自身成为head节点）
		//--
		//为什么head的后继节点可以试图获得锁：
		//当一个节点释放资源时，head节点仍然存在于链表中（并没有被删除），而后继节点被唤醒后，可以获得资源
		for (;;) {
			final Node p = node.predecessor();
			if (p == head && tryAcquire(arg)) {
				setHead(node);
				p.next = null; // help GC
				failed = false;
				return interrupted;
			}
			if (shouldParkAfterFailedAcquire(p, node) &&
				parkAndCheckInterrupt())
				interrupted = true;
		}
	} finally {
		if (failed)
			cancelAcquire(node);
	}
}

//设置前继节点的waitStatus为SIGNAL
//返回：是否需要park 当前Node.thread
//注意：该方法可能会调整node链，也可能会被并发调用
//为什么并发调用时，还是正常的：
//设node1.thread 和 node2.thread上 均在执行该方法，则意味着node1和node2均未获取到资源，且node1一定在node2的前面
//这里的调整node链，仅仅是在重设Node.prev（=一个没被cancel的Node）
//则一般情况下，node2.prev最差的情况下为node1（既是：node2并不会调整 node1之前的Node链）
//则，并发调用是安全的
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
	int ws = pred.waitStatus;
	if (ws == Node.SIGNAL)
		/*
		 * This node has already set status asking a release
		 * to signal it, so it can safely park.
		 */
		return true;
		
	//CANCELED值为1（也只有该status是>0的）
	//如果前继的状态为cancel，那么向前寻找一个status不为cancel的节点，并使其成为node的前继（对节点链进行调整）
	//注意：这里的调整，仅仅是修改node.prev 和 最终prev.next，其间无效节点的next和prev是不修改的
	//是否产生并发问题：
		//如果线程1和线程2 都来shouldParkAfterFailedAcquire，则，两线程对应的Node（设为node1, node2），肯定存在 链表上的 先后关系
		//则，在不考虑cancel操作（AbstractQueuedSynchronizer#cancelAcquire）的情况下，node2的prev 最差情况下 为node1（而非node1之前的节点）
		//该情况下，会改变node1.next
		//设 线程2从此后，就一直未执行（注意：未被park）直到 线程1获得了资源 执行了逻辑 释放了资源后
		//当node1.next=node2被执行了，node1开始唤醒其next，线程2空被unpark
			//随后，线程2执行，会返回到acquireQueued继续执行for，因为其前继为head，则其最终很可能获得了资源
		//当node1.next=node2并未被执行，node1开始唤醒其next，线程2空被unpark
			//但其当前的next是被cancel的，那么会从tail来找到一个有效的node（即是node2），最后唤醒node2，线程2空被unpark
			//随后，线程2执行，node1.next=node2，会返回到acquireQueued继续执行for，会因为其前继是head，则其最终很可能获得了资源
		//则，不管如何，执行结果都是正确的，即使：共享变量在 并发读写
	//注意：此刻，函数返回值为false，则之后会再次进入acquireQueued的for循环中
	//则有可能经过该前继的调整，node的前继就为head了，可以试图获得资源了
	//也有可能node.thread被真的park
	if (ws > 0) {
		/*
		 * Predecessor was cancelled. Skip over predecessors and
		 * indicate retry.
		 */
		do {
			node.prev = pred = pred.prev;
		} while (pred.waitStatus > 0);
		pred.next = node;
	}
	//设置前继节点的status为SIGNAL（允许CAS失败）
	else {
		/*
		 * waitStatus must be 0 or PROPAGATE.  Indicate that we
		 * need a signal, but don't park yet.  Caller will need to
		 * retry to make sure it cannot acquire before parking.
		 */
		compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
	}
	return false;
}

//阻塞节点
//被唤醒后，返回：线程是否被interrupt
private final boolean parkAndCheckInterrupt() {
	LockSupport.park(this);
	return Thread.interrupted();
}
