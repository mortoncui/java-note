参见：
Java并发之AQS详解 - waterystone - 博客园
	http://www.cnblogs.com/waterystone/p/4920797.html

解决了什么 基本问题：
当在线程1请求资源时，如果失败，线程1如何被阻塞；
当其他线程释放了资源后，被阻塞的线程1 如何被自动唤醒

对上述流程进行了封装，则针对于 上层开发者，其只需要实现如下：
定义 如何能获得/释放 资源（参考于 AbstractQueuedSynchronizer#state的值）
	对于独占资源，需要实现：tryAcquire, tryRelease
	对于共享资源，需要实现：tryAcquireShared, tryReleaseShared
	--
	这也是为什么tryAcquire等方法不是abstract的原因：如果一种AQS的子类实现 仅仅是一种情况（独占资源，或者，共享资源），则没有必要实现 两组方法

采用了CAS的方式（并未采用Sychronized）
		
------------------------------------------------核心流程（可和ReentrantLock一起来查看）：
>>> acquire资源时
开发者来定义 什么情况下可获得资源（tryAcquire）
	提供了额外的state来协助实现
	state是什么：
		其是int类型，代表了资源
		如：对于ReentrantLock，state代表了 在某个线程上 一共成功申请了多少资源
			在lock时，会acquire，当state为0时，则可申请成功（后state+=1）
			在同一个线程上，继续acquire时，state+=1，
			而在release时，会使得state-=1，
			当其他线程申请资源时，只有state为0时，才可申请得到
如果能获得，那么继续客户流程
如果不能获得，那么会生成数据结构Node，并将Node入队列（链表表示）的尾部
	Node
		代表：本次资源申请，拥有thread, waitStatus等属性
		前驱后继：next, pre
		waitStatus
			SIGNAL：当该节点释放资源（即是：在该节点.thread上 调用了 release）时，需要唤醒后继节点.thread
	链表结构：拥有 head tail（一开始创建链表时，head和tail相等）
		head: 无意义的Node（一开始创建链表时），或，当前拥有资源的Node
	--
	当该Node是head的后继时，会试图获得资源（参见：acquireQueue中的for流程，即是：当该Node被唤醒时，还是会重走for流程）
		如果能获得，那么会设置自身为head，继续客户流程
			对于共享锁，此刻，会自动doReleaseShare 来再次唤醒 新head的后继节点
		如果不能获得资源，那么Node会被阻塞（先要找到（并调整前继节点）前继节点（其waitStatus为SIGNAL）），等待被唤醒，
			唤醒方式为：
				被head节点 unparkSuccessor
				或者，自身线程.interrupt
			唤醒后，还是继续走 试图获取资源的流程（acquireQueue中的for循环）
			
>>> release资源时
开发者来定义 释放资源（tryRelease）并告诉是否可以唤醒后续节点
如果最终允许唤醒后继节点，那么会唤醒后继节点.thread（离head最近的 未cancel的节点），使得其走 试图获得资源的流程
注意：此刻并没有调整Node队列（如：设置head）

release后，哪个线程能获取资源，一种情况：
对于非公平ReentrantLock，线程1持有资源，线程2在等待获取
当release时，线程1在tryRelease中修改state为0，并返回true来允许唤醒线程2
而线程x此刻来tryAcquire，其是有将state从0变成1的可能，当成功后，其获得了资源
回到线程2，其被唤醒后，在tryAcquire时 失败，最终又被park
此时，拥有资源的线程 并不是head.thread，而是Node队列之外的 线程x

----------------并发性保证:
aqs没有使用synchronized关键字

while+CAS方式：
当tryAcquire失败时，将生成Node 并添加其到队尾

非while：
情况1. 
在shouldParkAfterFailedAcquire中，通过 确保Node.pre.waitStatus为SIGNAL 这种方式，向前遍历（从Node开始）并移除无效中间Node（其waitStatus>0）
这样能够 和 向队尾添加Node 避免冲突（一个向前 一个向后），则，此刻用了 非while
--
情况2. 
在unparkSuccessor中，要唤醒head之后的 第一个Node（其waitStatus<=0）
采用了 从tail开始，向前遍历的方式
这看似和 shouldParkAfterFailedAcquire中的 移除Node 向冲突，但实质上并没有（因为，二者的条件 均是waitStatus<=0，即是：我在遍历的时候，你在移除，你移除的东西我也是不需要的）

----------------独占模式 共享模式:
是否只有一个线程能获得该资源
如果是：独占模式，如：ReentrantLock
否则：共享模式，如：CountDownLatch

----------------关于interrupt
非interrupt方式来获取：AbstractQueuedSynchronizer#acquire
当Node.thread被中断，LockSupport.park之后的流程会继续，则会走 试图获得资源的for流程，如果获取不到，还是会再一次被阻塞
	也即是：即使在其他线程上，调用了本Node.thread.interrupt()，其并不会抛出InterruptedException异常
而在其获取到资源后，其会主动 Node.thread.interrupt()（此刻，在Node.thread上再执行诸如Thread.sleep时，会抛出InterruptedException异常）

interrupt方式来获取：AbstractQueuedSynchronizer#acquireInterruptibly
最终执行到AbstractQueuedSynchronizer#doAcquireInterruptibly
	当Node.thread被中断，AbstractQueuedSynchronizer#parkAndCheckInterrupt继续，并返回了true
	会抛出InterruptedException异常
