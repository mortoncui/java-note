yield() 是Thread的静态方法
使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。
但是，如果该线程的优先级很高，则表面上让出了，到最后cpu再次选择线程时，因为优先级的原因还是选它来执行

yield不会释放 当前线程已经占用的锁

而sleep()同样是让出控制器，cpu会选择其他的线程来执行（因为当前线程已经sleep了）