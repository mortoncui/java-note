参见：
使用 FutureTask 的正确姿势 - ImportNew
	http://www.importnew.com/27305.html?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io

其实现了RunnableFuture接口，其需要被提供Callable

run：
//设置thread
UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())
...
try {
	result = c.call();
	ran = true;
} catch (Throwable ex) {
	result = null;
	ran = false;
	setException(ex);
}
if (ran)
	set(result);

set/setException：
两步CAS来设置state：
	第一步CAS：认为state是NEW，设置state到COMPLETING
	如果成功，则第二步CAS：
		设置outcome（为真实结果，或，在执行过程中抛出的异常）
		设置state（putOrderedInt的形式）
			NORMAL，或
			EXCEPTIONAL状态
	--
	为什么需要两次CAS：
		set/setException要求的初始状态为NEW，而cancel的 也是NEW
		set/setException 和 cancel 只能二选一
FutureTask#finishCompletion
	唤醒FutureTask.waiters表示的WaitNode链表：
		for (WaitNode q; (q = waiters) != null;) {
            if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {
				//唤醒以q为头的 链表：LockSupport.unpark(WaitNode.thread)
				
				break;			
			}
		}
	通知FutureTask子类（一个钩子）：通过done()

get（在线程2上）：
执行完毕 的描述：成功 或者 执行过程中抛出异常 或者 被取消
	state > COMPLETING
		可能的状态：成功NORMAL，异常EXCEPTIONAL，取消CANCELLED或INTERRUPTED
在执行完毕时，通知结果：FutureTask#report
在执行完毕前，线程2调用FutureTask.get时，线程2将有可能被阻塞（生成WaitNode（数据成员：Thread, next），LockSupport.park）
	awaitDone：
	内部含有for循环：根据state，执行有限步骤，随后继续for （有可能state已经变了，需要更新执行流程）
		for流程：
			是否执行完毕，是，返回。否则 继续
				后，通知结果：FutureTask#report
			是否COMPLETING，是，Thread.yield。否则 继续
			是否生成了node，否，生成node。否则 继续
				q = new WaitNode();
			是否入队了，否，入队。否则 继续
				UNSAFE.compareAndSwapObject(this, waitersOffset, q.next = waiters, q);
			LockSupport.park
		为什么是如此设计：设想下这个场景：
			执行线程上将要执行set，而线程2上调用get，而此刻state为NEW
			为线程2构建node，那么线程2一定要被挂起吗：
			当线程2对应的node 即将要加入到node链表时，执行线程占用CPU来执行：进入set体，构建了outcome，改变了state，并finishCompletion（因为线程2对应的node此刻还没在链表中，所以不会LockSupport.unpark）
			回到线程2，线程2对应的node被加入到node链表中
			再次执行for，因为state此刻已经为 NORMAL，所以 线程2将不会被挂起，awaitDone会直接返回
			综上所述，采用for的设计，是为了每执行一步，就需要再次检查state，来调整后续流程

cancel：
public boolean cancel(boolean mayInterruptIfRunning) {
	if (!(
		//针对state：必须为NEW：还没有 执行到/成功进入到 set/setException
		//这里的compareAndSwapInt到INTERRUPTING/CANCELLED 的手法 同于 set/setException中的compareAndSwapInt到COMPLETING
		//因为二者执行完毕后，都会执行finishCompletion（则该completion的调用处 只能 二选一：set/setException 或者 cancel）
		//也要注意：
		//cancel操作，可能并不会使得 run()中 c.call()抛出异常，即是：c.call()可能会继续执行下去（只是之后的set/setException均因state而没有正常执行）
		state == NEW &&
		UNSAFE.compareAndSwapInt(this, stateOffset, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))
		return false;
	try {    // in case call to interrupt throws exception
		if (mayInterruptIfRunning) {
			try {
				Thread t = runner;
				//runner.intercept可能使得 run()中的执行体快速结束
				//注意：setException中 因为state已经变成了INTERRUPTING，而其允许进入的state为NEW，则其不会执行任何
				//run的执行体：
				//	try {
				//		result = c.call();
				//		ran = true;
				//	} catch (Throwable ex) {
				//		result = null;
				//		ran = false;
				//		setException(ex);
				//	}
				//	if (ran)
				//		set(result);
				if (t != null)
					t.interrupt();
			} finally { // final state
				UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);
			}
		}
	} finally {
		finishCompletion();
	}
	return true;
}
